<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¦™æ¸¯å°å­¸æ•¸å­¸ - ç«‹é«”åœ–å½¢å±•é–‹åœ–äº’å‹•ç¤ºç¯„</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --bg-color: #f5f7fa;
            --panel-bg: rgba(255, 255, 255, 0.95);
        }
        body {
            font-family: 'Segoe UI', Microsoft JhengHei, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            background: radial-gradient(circle, #ffffff 0%, #e6e9f0 100%);
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* UI Control Panel */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 20px 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 320px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.5);
        }

        .title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin-bottom: 5px;
        }

        .shape-selector {
            display: flex;
            justify-content: space-between;
            background: #eef2f7;
            padding: 4px;
            border-radius: 8px;
        }
        
        .shape-btn {
            flex: 1;
            border: none;
            background: transparent;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: #666;
            transition: all 0.2s;
        }
        
        .shape-btn.active {
            background: white;
            color: var(--primary-color);
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #555;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 2px 6px rgba(74, 144, 226, 0.4);
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #ddd;
            border-radius: 2px;
        }

        .instruction {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
            pointer-events: none;
        }

        /* SVG Element Styles */
        .face {
            stroke: #333;
            stroke-width: 1.5;
            stroke-linejoin: round;
            transition: fill 0.3s;
        }
        .face:hover {
            fill-opacity: 0.9;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div class="instruction">ğŸ–±ï¸ æ‹–æ›³æ—‹è½‰è¦–è§’ | æ»¾è¼ªç¸®æ”¾</div>
        <svg id="main-svg" viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice">
            <g id="scene-group"></g>
        </svg>

        <div class="controls">
            <div class="title">ç«‹é«”åœ–å½¢å±•é–‹åœ–</div>
            
            <div class="shape-selector">
                <button class="shape-btn active" onclick="setShape('cube')">æ­£æ–¹é«”</button>
                <button class="shape-btn" onclick="setShape('pyramid')">å››è§’éŒ</button>
                <button class="shape-btn" onclick="setShape('prism')">ä¸‰è§’æŸ±</button>
            </div>

            <div class="slider-container">
                <div class="slider-label">
                    <span>å±•é–‹</span>
                    <span id="fold-percent">0%</span>
                    <span>æ‘ºç–Š</span>
                </div>
                <input type="range" id="fold-slider" min="0" max="100" value="0" step="1">
            </div>
        </div>
    </div>

<script>
/**
 * ç°¡æ˜“ 3D å¼•æ“èˆ‡åœ–å½¢æ•¸æ“šå®šç¾©
 */

// æ•¸å­¸å·¥å…·
const Math3D = {
    rotateX: (theta) => [
        [1, 0, 0],
        [0, Math.cos(theta), -Math.sin(theta)],
        [0, Math.sin(theta), Math.cos(theta)]
    ],
    rotateY: (theta) => [
        [Math.cos(theta), 0, Math.sin(theta)],
        [0, 1, 0],
        [-Math.sin(theta), 0, Math.cos(theta)]
    ],
    rotateZ: (theta) => [
        [Math.cos(theta), -Math.sin(theta), 0],
        [Math.sin(theta), Math.cos(theta), 0],
        [0, 0, 1]
    ],
    multiply: (m, v) => { // Matrix (3x3) x Vector (3)
        return [
            m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
            m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
            m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
        ];
    },
    multiplyMatrices: (a, b) => { // 3x3 x 3x3
        let result = [[0,0,0],[0,0,0],[0,0,0]];
        for(let i=0; i<3; i++) {
            for(let j=0; j<3; j++) {
                for(let k=0; k<3; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return result;
    },
    identity: () => [[1,0,0],[0,1,0],[0,0,1]],
    add: (v1, v2) => [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]],
    sub: (v1, v2) => [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]]
};

// åœ–å½¢å®šç¾©
// çµæ§‹ï¼šæ¯å€‹åœ–å½¢ç”±ä¸€å€‹ Root Face (æ ¹é¢) å’Œä¸€ç³»åˆ—å­é¢ (Children) çµ„æˆ
// Children å®šç¾©ï¼š{ vertices: [], hinge: [v1_idx, v2_idx], angleMultiplier: 1, color: '', children: [] }
// hinge æ˜¯é€£æ¥åˆ°çˆ¶é¢çš„é‚Šï¼ŒangleMultiplier å®šç¾©æ‘ºç–Šè§’åº¦çš„å€ç‡ (é€šå¸¸ç‚º 1ï¼Œå³ 90åº¦)

const SHAPES = {
    cube: {
        name: "æ­£æ–¹é«”",
        baseColor: "#4a90e2",
        // 1-4-1 å±•é–‹åœ–çµæ§‹
        root: {
            // ä¸­å¤®é¢
            vertices: [[-50,-50,0], [50,-50,0], [50,50,0], [-50,50,0]], 
            children: [
                {   // ä¸Š
                    vertices: [[-50,-150,0], [50,-150,0], [50,-50,0], [-50,-50,0]],
                    hingeEdge: 0, // ç›¸å°æ–¼çˆ¶é¢çš„é‚Šç´¢å¼• (çˆ¶é¢: 0->1, 1->2, 2->3, 3->0) - é€™è£¡ç°¡åŒ–é‚è¼¯ï¼Œç›´æ¥å®šç¾©ç›¸å°æ–¼çˆ¶é¢çš„ä½ç§»
                    // ç‚ºäº†é€šç”¨æ€§ï¼Œæˆ‘å€‘æ”¹ç”¨ "ç›¸å°åæ¨™" å’Œ "æ—‹è½‰è»¸" çš„æ¦‚å¿µ
                    // é€™è£¡æ¡ç”¨æ›´ç°¡å–®çš„ Scene Graphï¼šæ¯å€‹å­ç¯€é»å®šç¾©å…¶åœ¨ã€Œå±•é–‹ç‹€æ…‹ã€ä¸‹çš„é ‚é»ï¼Œä»¥åŠã€Œæ‘ºç–Šè»¸ã€
                    // æ‘ºç–Šè»¸ç”±çˆ¶é¢çš„æŸæ¢é‚Šå®šç¾©ã€‚
                    // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘ç¡¬ç·¨ç¢¼æ¯å€‹é¢çš„æ•¸æ“šå’Œå±¤ç´šã€‚
                    
                    // id: 1 (ä¸Š), é€£æ¥ root çš„é‚Š: p0-p1 (top edge of root is p0-p1 if defined ccw?)
                    // è®“æˆ‘å€‘ç”¨ç°¡å–®çš„ç›¸å°åç§»å®šç¾©ï¼š
                    // Root: Center square.
                    // Child 1 (Top): Attached to Root's top edge.
                    attachTo: [0, 1], // Root vertices indices 0 and 1 (assuming -50,-50 and 50,-50)
                    points: [[-50,-150,0], [50,-150,0]], // The new points
                    foldAngle: 90,
                    axis: "x", // World axis to rotate around when flat? No, axis is the edge vector.
                    children: [
                        {
                            // æœ€ä¸Šé¢çš„é¡å¤–ä¸€å¡Š (1-4-1 çš„é‚£å€‹ 1)
                            attachTo: [0, 1], // Attached to Child 1's first edge
                            points: [[-50,-250,0], [50,-250,0]],
                            foldAngle: 90,
                            children: []
                        }
                    ]
                },
                {   // å³
                    attachTo: [1, 2],
                    points: [[150,-50,0], [150,50,0]],
                    foldAngle: 90,
                    children: []
                },
                {   // ä¸‹
                    attachTo: [2, 3],
                    points: [[50,150,0], [-50,150,0]],
                    foldAngle: 90,
                    children: []
                },
                {   // å·¦
                    attachTo: [3, 0],
                    points: [[-150,50,0], [-150,-50,0]],
                    foldAngle: 90,
                    children: []
                }
            ]
        }
    },
    pyramid: {
        name: "å››è§’éŒ",
        baseColor: "#e24a4a",
        root: {
            vertices: [[-50,-50,0], [50,-50,0], [50,50,0], [-50,50,0]], // Base Square
            children: [
                { attachTo: [0, 1], points: [[0, -130, 0]], foldAngle: 70, children: [] }, // Top Triangle
                { attachTo: [1, 2], points: [[130, 0, 0]], foldAngle: 70, children: [] }, // Right Triangle
                { attachTo: [2, 3], points: [[0, 130, 0]], foldAngle: 70, children: [] }, // Bottom Triangle
                { attachTo: [3, 0], points: [[-130, 0, 0]], foldAngle: 70, children: [] }  // Left Triangle
            ]
        }
    },
    prism: {
        name: "ä¸‰è§’æŸ±",
        baseColor: "#50e3c2",
        // å±•é–‹åœ–ï¼šé•·æ–¹å½¢-é•·æ–¹å½¢-é•·æ–¹å½¢ï¼Œä¸­é–“é•·æ–¹å½¢ä¸Šä¸‹å„ä¸€å€‹ä¸‰è§’å½¢
        root: {
            vertices: [[-50,-75,0], [50,-75,0], [50,75,0], [-50,75,0]], // Middle Rect
            children: [
                {   // Left Rect
                    attachTo: [3, 0], 
                    points: [[-150, 75, 0], [-150, -75, 0]], 
                    foldAngle: 60, 
                    children: [] 
                },
                {   // Right Rect
                    attachTo: [1, 2], 
                    points: [[150, -75, 0], [150, 75, 0]], 
                    foldAngle: 60, 
                    children: [] 
                },
                {   // Top Triangle
                    attachTo: [0, 1], 
                    points: [[0, -161.6, 0]], // height of equilateral triangle with side 100 is ~86.6. -75 - 86.6 = -161.6
                    foldAngle: 90, 
                    children: [] 
                },
                {   // Bottom Triangle
                    attachTo: [2, 3], 
                    points: [[0, 161.6, 0]], 
                    foldAngle: 90, 
                    children: [] 
                }
            ]
        }
    }
};

// æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
let state = {
    currentShape: 'cube',
    foldProgress: 0, // 0.0 to 1.0
    rotation: { x: -30, y: 45 },
    zoom: 1.0,
    isDragging: false,
    lastMouse: { x: 0, y: 0 }
};

// åˆå§‹åŒ–
const svg = document.getElementById('main-svg');
const sceneGroup = document.getElementById('scene-group');

function init() {
    render();
    
    // Event Listeners
    document.getElementById('fold-slider').addEventListener('input', (e) => {
        state.foldProgress = parseInt(e.target.value) / 100;
        document.getElementById('fold-percent').innerText = e.target.value + "%";
        render();
    });

    // Mouse Rotation
    const container = document.getElementById('canvas-container');
    container.addEventListener('mousedown', e => {
        state.isDragging = true;
        state.lastMouse = { x: e.clientX, y: e.clientY };
    });
    window.addEventListener('mousemove', e => {
        if (!state.isDragging) return;
        const dx = e.clientX - state.lastMouse.x;
        const dy = e.clientY - state.lastMouse.y;
        state.rotation.y += dx * 0.5;
        state.rotation.x -= dy * 0.5;
        state.lastMouse = { x: e.clientX, y: e.clientY };
        render();
    });
    window.addEventListener('mouseup', () => state.isDragging = false);
    
    // Zoom
    container.addEventListener('wheel', e => {
        e.preventDefault();
        state.zoom += e.deltaY * -0.001;
        state.zoom = Math.max(0.1, Math.min(3, state.zoom));
        render();
    });
}

// åˆ‡æ›åœ–å½¢
window.setShape = function(shapeKey) {
    state.currentShape = shapeKey;
    document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    
    // Reset slider slightly for effect
    state.foldProgress = 0;
    document.getElementById('fold-slider').value = 0;
    document.getElementById('fold-percent').innerText = "0%";
    
    render();
}

// æ¸²æŸ“æ ¸å¿ƒ
function render() {
    // æ¸…ç©ºå ´æ™¯
    while (sceneGroup.firstChild) {
        sceneGroup.removeChild(sceneGroup.firstChild);
    }

    const shapeData = SHAPES[state.currentShape];
    const faces = []; // Store all faces to sort by Z later

    // æ§‹å»ºè®Šæ›çŸ©é™£ (View Matrix)
    const rotX = Math3D.rotateX(state.rotation.x * Math.PI / 180);
    const rotY = Math3D.rotateY(state.rotation.y * Math.PI / 180);
    const viewMatrix = Math3D.multiplyMatrices(rotX, rotY);

    // éæ­¸è™•ç†åœ–å½¢å±¤ç´š
    function processFace(faceDef, parentMatrix, parentVertices) {
        // ç•¶å‰é¢çš„é ‚é»
        let currentVertices = [];

        // å¦‚æœæ˜¯ Rootï¼Œç›´æ¥ä½¿ç”¨å®šç¾©çš„é ‚é»
        if (!faceDef.attachTo) {
            currentVertices = faceDef.vertices.map(v => [...v]);
        } else {
            // å¦‚æœæ˜¯å­é¢ï¼ŒåŸºæ–¼çˆ¶é¢çš„é€£æ¥é‚Šé€²è¡Œè®Šæ›
            // 1. æ‰¾åˆ°é€£æ¥é‚Šçš„å…©å€‹é» (æ¨ç´è»¸)
            const p1 = parentVertices[faceDef.attachTo[0]];
            const p2 = parentVertices[faceDef.attachTo[1]];
            
            // 2. è¨ˆç®—è»¸å‘é‡
            const axis = Math3D.sub(p2, p1);
            const axisLen = Math.sqrt(axis[0]**2 + axis[1]**2 + axis[2]**2);
            const u = [axis[0]/axisLen, axis[1]/axisLen, axis[2]/axisLen]; // Unit vector
            
            // 3. å»ºç«‹æ—‹è½‰çŸ©é™£ (Rodrigues' rotation formula or Quaternion simplified)
            // é€™è£¡ç°¡åŒ–ï¼šæˆ‘å€‘åœ¨å±€éƒ¨ç©ºé–“æ§‹å»ºé¢ï¼Œç„¶å¾Œè®Šæ›ã€‚
            // ä½†æˆ‘å€‘å·²ç¶“å®šç¾©äº† "flat" ç‹€æ…‹ä¸‹çš„é»ã€‚
            // æ›´ç°¡å–®çš„æ–¹æ³•ï¼šè¨ˆç®—æ‘ºç–Šè§’åº¦
            const angle = (faceDef.foldAngle * state.foldProgress) * (Math.PI / 180);
            
            // ç¹è»¸æ—‹è½‰å‡½æ•¸ (Rotate point v around line passing through p1 with direction u by angle)
            const rotateAroundAxis = (v, p1, u, angle) => {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const t = 1 - c;
                const x = v[0]-p1[0], y = v[1]-p1[1], z = v[2]-p1[2];
                
                const newX = (t*u[0]*u[0] + c)*x + (t*u[0]*u[1] - s*u[2])*y + (t*u[0]*u[2] + s*u[1])*z;
                const newY = (t*u[0]*u[1] + s*u[2])*x + (t*u[1]*u[1] + c)*y + (t*u[1]*u[2] - s*u[0])*z;
                const newZ = (t*u[0]*u[2] - s*u[1])*x + (t*u[1]*u[2] + s*u[0])*y + (t*u[2]*u[2] + c)*z;
                
                return [newX+p1[0], newY+p1[1], newZ+p1[2]];
            };

            // çˆ¶é¢æä¾›çš„é‚Šæ˜¯ p1, p2ã€‚æ–°é¢çš„é»æ˜¯ faceDef.points
            // é»˜èªæ˜¯å¹³çš„ã€‚æˆ‘å€‘éœ€è¦ç¹è‘— p1-p2 è»¸æ—‹è½‰
            // æ³¨æ„ï¼šé€™è£¡å‡è¨­äº† faceDef.points å·²ç¶“åœ¨ "Flat" ç‹€æ…‹ä¸‹çš„æ­£ç¢ºä½ç½®
            // æˆ‘å€‘çš„æ•¸æ“šå®šç¾©æ¯”è¼ƒæ··é›œï¼Œç‚ºäº†ç°¡å–®ï¼Œæˆ‘å€‘å‹•æ…‹è¨ˆç®— Flat ä½ç½®æ¯”è¼ƒå¥½ï¼Œä½†é€™è£¡ç‚ºäº†ä»£ç¢¼çŸ­ï¼Œ
            // æˆ‘å€‘å‡è¨­ faceDef.points æ˜¯ç›¸å°æ–¼ attachTo çš„é‚Šå‘å¤–å»¶ä¼¸çš„ã€‚
            // å¯¦éš›ä¸Šï¼Œéæ­¸é‚è¼¯ä¸­ï¼Œæˆ‘å€‘æ‡‰è©² "ç¹¼æ‰¿" çˆ¶é¢çš„è®Šæ›ï¼Œç„¶å¾Œå†ç–ŠåŠ è‡ªå·±çš„æ‘ºç–Šæ—‹è½‰ã€‚
            
            // ä¿®æ­£é‚è¼¯ï¼š
            // 1. å°‡æ–°é»è¦–ç‚ºèˆ‡çˆ¶é¢å…±é¢ (å› ç‚ºæ˜¯å±•é–‹åœ–)ã€‚
            //    é€™è£¡çš„æ•¸æ“šçµæ§‹ä¸­ï¼Œå­é¢çš„ points å…¶å¯¦æ˜¯çµ•å°åæ¨™(åœ¨å±•é–‹å¹³é¢ä¸Š)ã€‚
            //    æ‰€ä»¥æˆ‘å€‘åªéœ€è¦å°é€™äº›é»æ‡‰ç”¨ "ç´¯ç©çš„æ‘ºç–Šæ—‹è½‰"ã€‚
            //    ä½†æ˜¯æ¯å€‹å­é¢éƒ½ä¾è³´æ–¼å…¶çˆ¶é¢çš„æ—‹è½‰ç‹€æ…‹ã€‚
            
            // å›æº¯æ€è·¯ï¼šå…¶å¯¦æ¯å€‹é¢åªéœ€è¦ç¹è‘—å®ƒèˆ‡çˆ¶é¢çš„äº¤ç•Œç·šæ—‹è½‰ `angle` åº¦ã€‚
            // é€™å€‹æ—‹è½‰æœƒå¸¶å‹•å®ƒæ‰€æœ‰çš„å­å­«é¢ã€‚
            // æ‰€ä»¥æˆ‘å€‘ä¸éœ€è¦æ§‹å»ºå¾©é›œçš„ Scene Graphï¼Œåªéœ€è¦éæ­·æ¨¹ã€‚
            // æ ¹é¢ä¸å‹•ã€‚
            // å­é¢ç¹è‘—èˆ‡æ ¹é¢çš„é‚Šæ—‹è½‰ã€‚
            // å­«é¢ç¹è‘—èˆ‡å­é¢çš„é‚Šæ—‹è½‰ï¼ˆæ­¤æ™‚é‚Šå·²ç¶“è¢«å­é¢æ—‹è½‰éäº†ï¼‰ã€‚
            
            // å¯¦ä½œï¼š
            // æˆ‘å€‘å…ˆå®šç¾©åˆå§‹çš„ "Flat" é ‚é»é›†åˆã€‚é€™éœ€è¦ä¸€å€‹éæ­¸å‡½æ•¸ä¾†æ§‹å»ºåˆå§‹é ‚é»åˆ—è¡¨ã€‚
            // ä½†æˆ‘å€‘çš„æ•¸æ“šçµæ§‹æœ‰é»æ··åˆã€‚
            // è®“æˆ‘å€‘æ¡ç”¨ "å‹•æ…‹è¨ˆç®—"ï¼š
            // è¼¸å…¥æ˜¯ parentVertices (å·²ç¶“æ˜¯ 3D ç©ºé–“ä¸­æ­£ç¢ºä½ç½®)ã€‚
            // è¼¸å…¥ faceDef.points (é€™æ˜¯æœ¬åœ°å®šç¾©çš„ 2D å½¢ç‹€çš„å»¶ä¼¸éƒ¨åˆ†)ã€‚
            // æˆ‘å€‘éœ€è¦å…ˆæŠŠå®ƒå€‘æ”¾åˆ° parentVertices çš„å¹³é¢ä¸Š (Flat ç‹€æ…‹)ï¼Œç„¶å¾Œå†æ—‹è½‰ã€‚
            
            // ç‚ºäº†ç°¡åŒ–ç¤ºç¯„ï¼Œæˆ‘å€‘å‡è¨­æ‰€æœ‰æ•¸æ“šçš„åˆå§‹ vertices éƒ½æ˜¯åœ¨ Z=0 å¹³é¢ä¸Šå®šç¾©å¥½çš„å±•é–‹åœ–åæ¨™ã€‚
            // æˆ‘å€‘åªéœ€è¦è¨ˆç®—æ¯å€‹é¢çš„ "ç´¯ç©è®Šæ›çŸ©é™£"ã€‚
            
            // é‡æ–°å®šç¾©è™•ç†æµç¨‹ï¼š
            // 1. æ¯å€‹é¢æœ‰ä¸€å€‹åˆå§‹çš„ Flat Vertices (éœ€é è¨ˆç®—æˆ–ç¡¬ç·¨ç¢¼)ã€‚
            //    ä¸Šé¢çš„æ•¸æ“šçµæ§‹ä¸­ï¼Œpoints æ˜¯ Flat åæ¨™ã€‚
            // 2. æ¯å€‹é¢æœ‰ä¸€å€‹è®Šæ›çŸ©é™£ Tã€‚
            //    Root: T = I
            //    Child: T = Parent_T * Rotate(around hinge edge, angle)
            // 3. æœ€çµ‚é ‚é» = Flat_Vertex * T
            
            // è®“æˆ‘å€‘ç¡¬ç·¨ç¢¼ Flat åæ¨™åˆ°æ•¸æ“šçµæ§‹ä¸­ï¼Œé¿å…è¤‡é›œè¨ˆç®—ã€‚
            // (ä¸Šé¢çš„æ•¸æ“šçµæ§‹å…¶å¯¦å·²ç¶“æ˜¯ Flat å…¨å±€åæ¨™äº†ï¼Œé™¤äº† attachTo æ˜¯ç´¢å¼•)
            
            // è¨ˆç®— Hinge (Pivot Line)
            // Hinge æ˜¯ç”± Parent è®Šæ›å¾Œçš„é ‚é»æ±ºå®šçš„ã€‚
            const hingeP1 = parentVertices[faceDef.attachTo[0]];
            const hingeP2 = parentVertices[faceDef.attachTo[1]];
            
            // æ§‹å»ºæ–°çš„é ‚é»
            // åˆå§‹é» (Flat) -> æ‡‰ç”¨ç•¶å‰ç´¯ç©çš„æ—‹è½‰
            // å•é¡Œï¼šå¦‚æœåªç”¨ Parent Matrixï¼Œç„¡æ³•è¡¨é” "ç¹è‘—é‚Šæ—‹è½‰"ã€‚
            // æ­£ç¢ºåšæ³•ï¼š
            // Current Points = Transform(Original Flat Points)
            // Transform æ˜¯ç´¯ç©çš„ã€‚
            // ä½†æ˜¯ "ç¹é‚Šæ—‹è½‰" çš„é‚Šæ˜¯å‹•æ…‹çš„ã€‚
            
            // ç°¡åŒ–ç®—æ³• (Forward Kinematics):
            // 1. ç²å–åŸå§‹ Flat åæ¨™ (æˆ‘å€‘æœ‰)ã€‚
            // 2. å°æ–¼ç•¶å‰é¢ï¼Œå…ˆæ‡‰ç”¨çˆ¶é¢çš„æ‰€æœ‰è®Šæ›ã€‚
            // 3. ç„¶å¾Œï¼Œæ‰¾åˆ°ç•¶å‰ Hinge ç·š (åœ¨çˆ¶é¢è®Šæ›å¾Œçš„ç©ºé–“ä¸­)ã€‚
            // 4. æ§‹å»ºä¸€å€‹ "ç¹è©² Hinge ç·šæ—‹è½‰ angle" çš„è®Šæ›ã€‚
            // 5. å°‡æ­¤è®Šæ›æ‡‰ç”¨æ–¼ç•¶å‰é¢åŠå…¶æ‰€æœ‰å¾Œä»£ã€‚
            
            // é€™æœ‰é»é›£å¯«åœ¨ç°¡å–®å¾ªç’°è£¡ã€‚
            // è®“æˆ‘å€‘ç”¨ "å †ç–Šè®Šæ›" çš„æ–¹å¼ã€‚
            // æ¯å€‹é¢éƒ½å¾ Flat ç‹€æ…‹é–‹å§‹ã€‚
            // å®ƒçš„æœ€çµ‚ä½ç½® = FlatPos 
            //    * Rotate(Root-Child1 Edge) 
            //    * Rotate(Child1-Child2 Edge) ...
            // æ³¨æ„æ—‹è½‰é †åºå’Œè»¸çš„è®ŠåŒ–ã€‚
            
            // æœ€ç©©å®šçš„æ–¹æ³•ï¼š
            // éæ­¸å‚³é "çˆ¶é¢é ‚é»"ã€‚
            // è¨ˆç®—å‡º Hinge Edgeã€‚
            // ç•¶å‰é¢çš„é ‚é»é¦–å…ˆå®šä½åœ¨ "èˆ‡çˆ¶é¢å…±é¢" (å³ Flat ç‹€æ…‹ä¸‹çš„ç›¸å°ä½ç½®ï¼Œé€™å¯ä»¥é€šéå¹¾ä½•æ¨å°ï¼Œæˆ–è€…æˆ‘å€‘ä¿¡ä»»æ•¸æ“šä¸­çš„ Flat åæ¨™èˆ‡ Parent Flat åæ¨™çš„é—œä¿‚)ã€‚
            // å…¶å¯¦æ•¸æ“šè£¡çš„ points å·²ç¶“æ˜¯ Flat åæ¨™ã€‚
            // æ‰€ä»¥ï¼š
            // 1. æ‹¿åˆ°è‡ªå·±çš„ Flat Pointsã€‚
            // 2. é€™äº›é»é¦–å…ˆè¦ç¶“é "çˆ¶é¢å·²ç¶“ç¶“æ­·çš„æ‰€æœ‰è®Šæ›"ã€‚
            // 3. ç„¶å¾Œï¼Œé€™äº›é»è¦ "ç¹è‘— Hinge Edge" å†è½‰ `angle` åº¦ã€‚
            
            // ä½†é€™æœ‰ä¸€å€‹å•é¡Œï¼šçˆ¶é¢çš„è®Šæ›å·²ç¶“åŒ…å«äº†çˆ¶é¢çš„æ—‹è½‰ã€‚
            // å¦‚æœæˆ‘å€‘å…ˆæ‡‰ç”¨çˆ¶é¢è®Šæ›ï¼Œæˆ‘å€‘å¾—åˆ°çš„é»æ˜¯ "é™„è‘—åœ¨çˆ¶é¢ä¸Šï¼Œä¸”æœªç›¸å°æ–¼çˆ¶é¢æ‘ºç–Š" çš„ç‹€æ…‹ã€‚
            // é€™æ­£æ˜¯æˆ‘å€‘æƒ³è¦çš„ï¼
            // ç„¶å¾Œæˆ‘å€‘å†æ‡‰ç”¨ "ç›¸å°æ–¼çˆ¶é¢çš„æ‘ºç–Š"ã€‚
            
            // æ­¥é©Ÿï¼š
            // 1. å®šç¾©é¢çš„åˆå§‹ Flat åæ¨™ (Base Shape)ã€‚
            //    Root çš„ Flat åæ¨™å·²çŸ¥ã€‚
            //    Children çš„ Flat åæ¨™å·²çŸ¥ (points)ã€‚
            // 2. è®Šæ›é‚è¼¯ï¼š
            //    function getTransformedVertices(face, parentTransformFunc)
            //      Let flatVerts = face.points;
            //      Let tempVerts = flatVerts.map(parentTransformFunc); // è·Ÿéš¨çˆ¶é¢ç§»å‹•
            //      Let hinge = [ transformedParent[idx1], transformedParent[idx2] ];
            //      Let myRotateFunc = (v) => rotateAroundAxis(v, hinge[0], hingeVec, angle);
            //      Let finalVerts = tempVerts.map(myRotateFunc);
            //      return finalVerts, combineFunc(parentTransformFunc, myRotateFunc);
            
            // æˆ‘å€‘éœ€è¦æŠŠè®Šæ›åŒ…è£æˆå‡½æ•¸å‚³éã€‚
        }
        
        // å¯¦ä½œä¸Šè¿°é‚è¼¯
        // ç‚ºäº†ç°¡å–®ï¼Œæˆ‘å€‘ä¸å‚³éå‡½æ•¸ï¼Œç›´æ¥å‚³éé ‚é»å’Œéæ­¸è¨ˆç®—
        
        // è¼”åŠ©ï¼šå°ä¸€çµ„é»æ‡‰ç”¨è®Šæ›
        // é€™è£¡æˆ‘å€‘ç™¼ç¾ä¸€å€‹å•é¡Œï¼šå¦‚æœåªä¿å­˜é»ï¼Œç„¡æ³•å° "åŸå§‹ Flat åæ¨™" æ‡‰ç”¨è®Šæ›éˆã€‚
        // æˆ‘å€‘éœ€è¦ "ç•¶å‰ç‹€æ…‹ä¸‹çš„é»"ã€‚
        // 1. è®“æ–°é» = ç¶“éçˆ¶é¢è®Šæ›å¾Œçš„ Flat Points (å³å®ƒåœ¨çˆ¶é¢å¹³é¢ä¸Š)ã€‚
        //    æ€éº¼å¾—åˆ°ï¼Ÿ
        //    æˆ‘å€‘å¯ä»¥ç°¡å–®åœ°èªç‚ºï¼šæ‰€æœ‰é¢ä¸€é–‹å§‹éƒ½æ˜¯ Flat çš„ã€‚
        //    æˆ‘å€‘éæ­·å±¤ç´šæ¨¹ï¼Œè¨ˆç®—æ¯å€‹ç¯€é»ç›¸å°æ–¼çˆ¶ç¯€é»çš„ "å±€éƒ¨æ—‹è½‰"ã€‚
        //    é€™éœ€è¦å±€éƒ¨åæ¨™ç³»ã€‚
        
        // æ›¿ä»£æ–¹æ¡ˆ (ç›´æ¥æ“ä½œé ‚é»)ï¼š
        // æ¯å€‹ç¯€é»ä¿å­˜å…¶ç•¶å‰é ‚é»ã€‚
        // éæ­·æ¨¹ã€‚å°æ–¼ç¯€é» Nï¼Œå®ƒæœ‰ä¸€å€‹ Hinge (ç”±çˆ¶ç¯€é» P çš„å…©å€‹é ‚é»æ±ºå®š)ã€‚
        // æˆ‘å€‘è¨ˆç®— N (åŠ N çš„æ‰€æœ‰å­å­«) ç¹ Hinge çš„æ—‹è½‰ã€‚
        // é€™æ¨£åšæ„å‘³è‘—ï¼šç•¶æˆ‘å€‘æ—‹è½‰ Child æ™‚ï¼Œæˆ‘å€‘å¿…é ˆåŒæ™‚æ—‹è½‰ GrandChildã€‚
        // é€™æ˜¯ä¸€å€‹å¾Œåºéæ­·æˆ–è€…å±¤ç´šæ›´æ–°ã€‚
        
        // ç®—æ³•ï¼š
        // 1. é‡ç½®æ‰€æœ‰é ‚é»åˆ° Flat ç‹€æ…‹ (å¾ SHAPES æ•¸æ“šè®€å–)ã€‚
        // 2. éæ­·æ¨¹ (DFS)ã€‚
        //    å°æ–¼æ¯å€‹ç¯€é» (Face)ï¼Œå¦‚æœå®ƒæœ‰æ‘ºç–Šè§’åº¦ > 0ï¼š
        //      æ‰¾åˆ°å®ƒçš„ Hinge (é€£æ¥åˆ°çˆ¶é¢çš„é‚Š)ã€‚
        //      è¨ˆç®—æ—‹è½‰çŸ©é™£ M (ç¹ Hinge è½‰ angle)ã€‚
        //      å°‡ M æ‡‰ç”¨æ–¼è©²ç¯€é»çš„æ‰€æœ‰é ‚é»ï¼Œä»¥åŠè©²ç¯€é»çš„æ‰€æœ‰å­å­«ç¯€é»çš„é ‚é»ã€‚
        
        // é€™éœ€è¦æˆ‘å€‘å…ˆæŠŠæ‰€æœ‰é ‚é»å±•å¹³ï¼Œå»ºç«‹å¥½æ¨¹çµæ§‹å¼•ç”¨ï¼Œç„¶å¾Œä¸€æ¬¡æ€§è¨ˆç®—ã€‚
    }
    
    // 1. æ§‹å»ºå ´æ™¯åœ– (Flat State)
    let allFaces = []; // { id, vertices: [], children: [], parent: null, foldAngle: ... }
    
    // éæ­¸æ§‹å»º
    function buildTree(def, parentFace) {
        let vertices = [];
        if (parentFace === null) {
            vertices = def.vertices.map(v => [...v]); // Copy
        } else {
            vertices = def.points.map(v => [...v]);
        }
        
        let face = {
            vertices: vertices,
            children: [],
            color: shapeData.baseColor,
            alpha: 0.6,
            attachTo: def.attachTo, // Indices in parent
            foldAngle: def.foldAngle || 0
        };
        
        if (parentFace) {
            parentFace.children.push(face);
            face.parent = parentFace;
        }
        
        if (def.children) {
            def.children.forEach(c => buildTree(c, face));
        }
        
        allFaces.push(face);
        return face;
    }
    
    const rootFace = buildTree(shapeData.root, null);
    
    // 2. æ‡‰ç”¨æ‘ºç–Š (Animation Logic)
    // æˆ‘å€‘éœ€è¦ä¸€å€‹å‡½æ•¸ï¼šrotateBranch(face, axisP1, axisP2, angle)
    function rotateBranch(face, p1, p2, angle) {
        // æ—‹è½‰ç•¶å‰é¢çš„æ‰€æœ‰é»
        const axis = Math3D.sub(p2, p1);
        const axisLen = Math.sqrt(axis[0]**2 + axis[1]**2 + axis[2]**2);
        if (axisLen < 0.001) return;
        const u = [axis[0]/axisLen, axis[1]/axisLen, axis[2]/axisLen];
        
        const rotateFunc = (v) => {
            // Rodrigues rotation
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const t = 1 - c;
            const x = v[0]-p1[0], y = v[1]-p1[1], z = v[2]-p1[2];
            return [
                (t*u[0]*u[0] + c)*x + (t*u[0]*u[1] - s*u[2])*y + (t*u[0]*u[2] + s*u[1])*z + p1[0],
                (t*u[0]*u[1] + s*u[2])*x + (t*u[1]*u[1] + c)*y + (t*u[1]*u[2] - s*u[0])*z + p1[1],
                (t*u[0]*u[2] - s*u[1])*x + (t*u[1]*u[2] + s*u[0])*y + (t*u[2]*u[2] + c)*z + p1[2]
            ];
        };
        
        face.vertices = face.vertices.map(rotateFunc);
        
        // éæ­¸æ—‹è½‰æ‰€æœ‰å­å­«
        face.children.forEach(child => {
            rotateBranch(child, p1, p2, angle);
        });
    }
    
    // åŸ·è¡Œæ‘ºç–Šéæ­· (BFS/DFS å‡å¯ï¼Œä½†å¿…é ˆå¾ Root çš„å­ç¯€é»é–‹å§‹)
    // é€™è£¡é‡è¦çš„æ˜¯é †åºï¼šç•¶æˆ‘å€‘æ—‹è½‰ä¸€å€‹ Parent æ™‚ï¼ŒChildren å·²ç¶“è¢«å¸¶è‘—å‹•äº†ï¼Ÿ
    // ä¸ï¼Œä¸Šé¢çš„ rotateBranch å·²ç¶“è™•ç†äº† "å¸¶å‹•å­å­«"ã€‚
    // æ‰€ä»¥æˆ‘å€‘åªéœ€è¦å°æ¯å€‹ç¯€é»ï¼ŒæŒ‰ç…§ "å¾æ ¹åˆ°è‘‰" çš„é †åºï¼Œè¨ˆç®—å®ƒç›¸å°æ–¼çˆ¶ç¯€é»çš„æ‘ºç–Šå³å¯ã€‚
    // å› ç‚ºå¦‚æœå…ˆè½‰äº†å­ç¯€é»ï¼Œå†è½‰çˆ¶ç¯€é»ï¼Œå­ç¯€é»æœƒè¢«çˆ¶ç¯€é»çš„æ—‹è½‰ "å†æ¬¡" å¸¶å‹•ï¼Œé€™æ˜¯æ­£ç¢ºçš„ã€‚
    // ç­‰ç­‰ï¼Œ"å†æ¬¡å¸¶å‹•" æ˜¯æ­£ç¢ºçš„å—ï¼Ÿ
    // æ˜¯çš„ã€‚ç‰©ç†ä¸Šï¼Œå¦‚æœæˆ‘æ‘ºèµ·å´é¢ï¼Œå´é¢ä¸Šçš„è“‹å­ä¹Ÿæœƒè·Ÿè‘—å‹•ã€‚ç„¶å¾Œæˆ‘å†æ‘ºè“‹å­ã€‚
    // æˆ–è€…æˆ‘å…ˆæ‘ºè“‹å­ï¼Œå†æ‘ºå´é¢ã€‚çµæœæ˜¯ä¸€æ¨£çš„ (å‰›é«”è®Šæ›çš„å¯äº¤æ›æ€§? ä¸ä¸€å®šï¼Œä½†å±¤ç´šæ—‹è½‰é€šå¸¸æ˜¯é€™æ¨£)ã€‚
    // ç‚ºäº†é‚è¼¯æ¸…æ™°ï¼Œæˆ‘å€‘æ¡ç”¨ DFSã€‚
    
    function applyFolding(face) {
        if (face.parent) {
            // è¨ˆç®— Hinge (æ­¤æ™‚ Parent å·²ç¶“å¯èƒ½è¢«ç§»å‹•éäº†ï¼Œé€™æ˜¯æ­£ç¢ºçš„ï¼Œæˆ‘å€‘éœ€è¦ç•¶å‰çš„ Hinge ä½ç½®)
            const p1 = face.parent.vertices[face.attachTo[0]];
            const p2 = face.parent.vertices[face.attachTo[1]];
            
            const angleRad = (face.foldAngle * state.foldProgress) * (Math.PI / 180);
            
            // æ—‹è½‰è‡ªå·±å’Œè‡ªå·±çš„å­å­«
            rotateBranch(face, p1, p2, angleRad);
        }
        
        // ç¹¼çºŒè™•ç†å­ç¯€é»
        face.children.forEach(child => applyFolding(child));
    }
    
    applyFolding(rootFace); // Start processing
    
    // 3. æŠ•å½±èˆ‡ç¹ªè£½ (Projection)
    // è¨ˆç®—æ¯å€‹é¢çš„ Z depth æ’åº
    let drawList = allFaces.map(face => {
        // è¦–åœ–è®Šæ›
        const viewVerts = face.vertices.map(v => Math3D.multiply(viewMatrix, v));
        
        // è¨ˆç®—ä¸­å¿ƒé» Z (ç”¨æ–¼æ’åº)
        let avgZ = 0;
        viewVerts.forEach(v => avgZ += v[2]);
        avgZ /= viewVerts.length;
        
        return {
            face: face,
            verts: viewVerts,
            z: avgZ
        };
    });
    
    // Sort painter's algorithm
    drawList.sort((a, b) => b.z - a.z);
    
    // Draw
    drawList.forEach(item => {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        
        // Perspective Projection
        // Simple: x' = x / (z + dist)
        const d = 800;
        const screenVerts = item.verts.map(v => {
            const scale = d / (d - v[2]) * state.zoom;
            return [
                v[0] * scale,
                v[1] * scale
            ];
        });
        
        // Construct Path D
        let dStr = `M ${screenVerts[0][0]} ${screenVerts[0][1]} `;
        for(let i=1; i<screenVerts.length; i++) {
            dStr += `L ${screenVerts[i][0]} ${screenVerts[i][1]} `;
        }
        dStr += "Z";
        
        path.setAttribute("d", dStr);
        path.setAttribute("class", "face");
        path.setAttribute("fill", item.face.color);
        path.setAttribute("fill-opacity", item.face.alpha);
        
        sceneGroup.appendChild(path);
        
        // ç¹ªè£½é ‚é»ç·¨è™Ÿ (Debug) æˆ– é‚Šæ¡†å„ªåŒ–
        // é€™è£¡åªç¹ªè£½é¢
    });
}

init();

</script>
</body>
</html>
