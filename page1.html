<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG 互動三角形角度示範</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f9;
            overflow: hidden; /* 防止拖曳時出現捲軸 */
        }

        h2 {
            color: #333;
            margin-bottom: 10px;
            pointer-events: none;
            user-select: none;
        }

        .instruction {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 20px;
            pointer-events: none;
            user-select: none;
        }

        #canvas-container {
            position: relative;
            width: 90vw; /* 響應式寬度 */
            height: 70vh; /* 響應式高度 */
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: default;
        }

        /* 三角形樣式 */
        .triangle {
            fill: rgba(66, 133, 244, 0.2);
            stroke: #4285f4;
            stroke-width: 3;
            stroke-linejoin: round;
        }

        /* 控制點樣式 */
        .control-point {
            fill: #db4437;
            stroke: white;
            stroke-width: 2;
            cursor: grab;
            transition: r 0.2s ease;
        }

        .control-point:hover {
            r: 10; /* 滑鼠懸停時放大 */
        }

        .control-point:active {
            cursor: grabbing;
            fill: #c53929;
        }

        /* 文字標籤樣式 */
        .angle-label {
            font-size: 16px;
            font-weight: bold;
            fill: #333;
            pointer-events: none; /* 讓滑鼠可以直接穿透文字點選下方的圓點 */
            text-anchor: middle;
            dominant-baseline: middle;
            user-select: none;
        }

        /* 角度弧線 (選配) */
        .angle-arc {
            fill: none;
            stroke: #f4b400;
            stroke-width: 2;
            opacity: 0.6;
        }
    </style>
</head>
<body>

    <h2>互動三角形角度計算</h2>
    <div class="instruction">拖動紅色頂點以改變形狀</div>

    <div id="canvas-container">
        <svg id="triangleSvg">
            <!-- 定義三個角度的弧線 -->
            <path id="arc0" class="angle-arc"></path>
            <path id="arc1" class="angle-arc"></path>
            <path id="arc2" class="angle-arc"></path>

            <!-- 三角形本體 -->
            <polygon id="polygon" class="triangle" points=""></polygon>

            <!-- 角度文字 -->
            <text id="text0" class="angle-label">0°</text>
            <text id="text1" class="angle-label">0°</text>
            <text id="text2" class="angle-label">0°</text>

            <!-- 三個可拖曳的頂點 (放在最後以確保在最上層) -->
            <circle id="p0" class="control-point" r="8"></circle>
            <circle id="p1" class="control-point" r="8"></circle>
            <circle id="p2" class="control-point" r="8"></circle>
        </svg>
    </div>

<script>
    // 初始化頂點座標 (相對於 SVG viewBox 或像素)
    // 這裡我們會在 window onload 時根據容器大小動態設定初始位置
    const points = [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
    ];

    const svg = document.getElementById('triangleSvg');
    const polygon = document.getElementById('polygon');
    const controls = [
        document.getElementById('p0'),
        document.getElementById('p1'),
        document.getElementById('p2')
    ];
    const texts = [
        document.getElementById('text0'),
        document.getElementById('text1'),
        document.getElementById('text2')
    ];
    const arcs = [
        document.getElementById('arc0'),
        document.getElementById('arc1'),
        document.getElementById('arc2')
    ];

    let activePointIndex = null;

    // 初始化：設定初始位置
    function init() {
        const rect = svg.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        // 設定一個正三角形作為預設值
        points[0] = { x: w * 0.5, y: h * 0.2 };
        points[1] = { x: w * 0.2, y: h * 0.8 };
        points[2] = { x: w * 0.8, y: h * 0.8 };

        updateView();
    }

    // 計算兩點距離
    function dist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // 餘弦定理計算角度 (回傳度數)
    function calculateAngle(a, b, c) {
        // cosA = (b^2 + c^2 - a^2) / 2bc
        const rad = Math.acos((b * b + c * c - a * a) / (2 * b * c));
        return (rad * 180 / Math.PI);
    }

    // 核心繪圖邏輯
    function updateView() {
        // 1. 更新三角形 Polygon
        const pointsStr = points.map(p => `${p.x},${p.y}`).join(' ');
        polygon.setAttribute('points', pointsStr);

        // 計算邊長
        const a = dist(points[1], points[2]); // 對應角0的邊
        const b = dist(points[0], points[2]); // 對應角1的邊
        const c = dist(points[0], points[1]); // 對應角2的邊

        // 計算角度
        const ang0 = calculateAngle(a, b, c);
        const ang1 = calculateAngle(b, a, c);
        const ang2 = calculateAngle(c, a, b);
        
        const angles = [ang0, ang1, ang2];

        // 計算重心 (Centroid)，用於推算文字標籤的偏移方向
        const cx = (points[0].x + points[1].x + points[2].x) / 3;
        const cy = (points[0].y + points[1].y + points[2].y) / 3;

        for (let i = 0; i < 3; i++) {
            // 2. 更新圓點位置
            controls[i].setAttribute('cx', points[i].x);
            controls[i].setAttribute('cy', points[i].y);

            // 3. 更新文字數值與位置
            // 計算從重心指向頂點的向量，將文字往外推一點
            const dx = points[i].x - cx;
            const dy = points[i].y - cy;
            const len = Math.sqrt(dx*dx + dy*dy);
            const offset = 35; // 文字距離頂點的偏移量
            
            // 正規化並應用偏移
            const textX = points[i].x + (dx / len) * offset;
            const textY = points[i].y + (dy / len) * offset;

            texts[i].setAttribute('x', textX);
            texts[i].setAttribute('y', textY);
            
            // 處理 NaN (例如三點重合時)
            const displayAngle = isNaN(angles[i]) ? 0 : Math.round(angles[i]);
            texts[i].textContent = `${displayAngle}°`;
        }
    }

    // --- 事件監聽 (拖曳邏輯) ---

    // 將滑鼠/觸控座標轉換為 SVG 內部座標
    function getMousePosition(evt) {
        const CTM = svg.getScreenCTM();
        if (evt.touches) { evt = evt.touches[0]; }
        return {
            x: (evt.clientX - CTM.e) / CTM.a,
            y: (evt.clientY - CTM.f) / CTM.d
        };
    }

    function startDrag(evt, index) {
        activePointIndex = index;
        // 防止選取文字或預設行為
        evt.preventDefault(); 
    }

    function drag(evt) {
        if (activePointIndex !== null) {
            evt.preventDefault();
            const coord = getMousePosition(evt);
            
            // 更新當前活動點的座標
            points[activePointIndex].x = coord.x;
            points[activePointIndex].y = coord.y;
            
            updateView();
        }
    }

    function endDrag() {
        activePointIndex = null;
    }

    // 綁定事件到三個控制點
    controls.forEach((circle, index) => {
        circle.addEventListener('mousedown', (e) => startDrag(e, index));
        circle.addEventListener('touchstart', (e) => startDrag(e, index), {passive: false});
    });

    // 綁定全局移動事件 (確保拖太快滑出圓點時也能感應)
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', endDrag);
    
    // 觸控事件
    window.addEventListener('touchmove', drag, {passive: false});
    window.addEventListener('touchend', endDrag);

    // 初始化繪製
    window.onload = init;
    // 視窗改變大小時重置 (可選)
    window.onresize = init; 

</script>
</body>
</html>
