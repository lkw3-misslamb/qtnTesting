import React, { useState, useEffect, useRef } from 'react';
import { Box, Square, Triangle, RefreshCcw, Info, MousePointer2 } from 'lucide-react';

// --- Constants & Types ---

const COLORS = {
  primary: '#3b82f6', // blue-500
  secondary: '#ef4444', // red-500
  tertiary: '#10b981', // green-500
  quaternary: '#f59e0b', // amber-500
  quinary: '#8b5cf6', // violet-500
  senary: '#ec4899', // pink-500
  bg: '#f8fafc',
  grid: '#e2e8f0',
};

// --- Helper Components ---

// A generic Face component using SVG to render grid lines
const SvgFace = ({ width, height, color, label, type = 'rect', gridSize = 50 }) => {
  const isTriangle = type === 'triangle';
  
  return (
    <div 
      className="absolute backface-visible border-2 border-gray-800 flex items-center justify-center select-none overflow-hidden"
      style={{
        width: width,
        height: height,
        backgroundColor: `${color}dd`, // slight transparency
        boxShadow: 'inset 0 0 20px rgba(0,0,0,0.1)',
      }}
    >
      {/* SVG Grid Overlay */}
      <svg width="100%" height="100%" className="absolute top-0 left-0 opacity-30 pointer-events-none">
        <defs>
          <pattern id={`grid-${label}`} width={gridSize} height={gridSize} patternUnits="userSpaceOnUse">
            <path d={`M ${gridSize} 0 L 0 0 0 ${gridSize}`} fill="none" stroke="black" strokeWidth="1" />
          </pattern>
        </defs>
        {isTriangle ? (
           // Simple clipping for triangle visual if needed, though CSS clip-path handles the shape
           <rect width="100%" height="100%" fill={`url(#grid-${label})`} />
        ) : (
           <rect width="100%" height="100%" fill={`url(#grid-${label})`} />
        )}
      </svg>
      
      {/* Label */}
      <span className="text-2xl font-bold text-gray-800 z-10">{label}</span>
    </div>
  );
};

// Recursive Face Component for the 3D Object Tree
const FoldableFace = ({ data, progress }) => {
  const { id, w, h, color, children, transformOrigin, rotateAxis, rotateDir, type } = data;

  // Calculate rotation based on progress (0 = 90deg/folded, 1 = 0deg/flat)
  // For standard cubic shapes, folded is 90deg.
  // We want progress 0 -> 90deg (or specific angle), progress 100 -> 0deg.
  
  let targetAngle = 90;
  if (data.targetAngle) targetAngle = data.targetAngle;

  const currentAngle = targetAngle * (1 - progress / 100) * rotateDir;

  return (
    <div
      style={{
        width: w,
        height: h,
        position: 'absolute',
        transformStyle: 'preserve-3d',
        transformOrigin: transformOrigin,
        transform: `rotate${rotateAxis}(${currentAngle}deg)`,
        transition: 'transform 0.1s linear', // smooth fast updates
      }}
    >
      {/* Render the face visual */}
      <div 
        style={{ 
          width: '100%', 
          height: '100%', 
          position: 'absolute',
          clipPath: type === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none'
        }}
      >
        <SvgFace width={w} height={h} color={color} label={id} type={type} />
      </div>

      {/* Render children faces attached to this one */}
      {children && children.map((child, idx) => (
        <div key={idx} style={{ position: 'absolute', top: child.y, left: child.x }}>
          <FoldableFace data={child} progress={progress} />
        </div>
      ))}
    </div>
  );
};

// --- Shape Definitions ---

const createCubeData = () => ({
  id: '底', w: 100, h: 100, color: COLORS.primary, type: 'rect', rotateAxis: 'X', rotateDir: 0, transformOrigin: 'center',
  children: [
    {
      id: '前', w: 100, h: 100, color: COLORS.secondary, x: 0, y: 100,
      rotateAxis: 'X', rotateDir: 1, transformOrigin: 'top', targetAngle: 90,
      children: []
    },
    {
      id: '後', w: 100, h: 100, color: COLORS.secondary, x: 0, y: -100,
      rotateAxis: 'X', rotateDir: -1, transformOrigin: 'bottom', targetAngle: 90,
      children: [
         // Attached to Back
         {
          id: '頂', w: 100, h: 100, color: COLORS.primary, x: 0, y: -100,
          rotateAxis: 'X', rotateDir: -1, transformOrigin: 'bottom', targetAngle: 90,
          children: []
        },
      ]
    },
    {
      id: '左', w: 100, h: 100, color: COLORS.tertiary, x: -100, y: 0,
      rotateAxis: 'Y', rotateDir: -1, transformOrigin: 'right', targetAngle: 90,
      children: []
    },
    {
      id: '右', w: 100, h: 100, color: COLORS.tertiary, x: 100, y: 0,
      rotateAxis: 'Y', rotateDir: 1, transformOrigin: 'left', targetAngle: 90,
      children: []
    }
  ]
});

const createCuboidData = () => ({ // Long box
  id: '底', w: 100, h: 150, color: COLORS.primary, type: 'rect', rotateAxis: 'X', rotateDir: 0, transformOrigin: 'center',
  children: [
    {
      id: '前', w: 100, h: 100, color: COLORS.secondary, x: 0, y: 150,
      rotateAxis: 'X', rotateDir: 1, transformOrigin: 'top', targetAngle: 90,
      children: []
    },
    {
      id: '後', w: 100, h: 100, color: COLORS.secondary, x: 0, y: -100,
      rotateAxis: 'X', rotateDir: -1, transformOrigin: 'bottom', targetAngle: 90,
      children: [
        {
          id: '頂', w: 100, h: 150, color: COLORS.primary, x: 0, y: -150,
          rotateAxis: 'X', rotateDir: -1, transformOrigin: 'bottom', targetAngle: 90,
          children: []
        },
      ]
    },
    {
      id: '左', w: 100, h: 150, color: COLORS.tertiary, x: -100, y: 0,
      rotateAxis: 'Y', rotateDir: -1, transformOrigin: 'right', targetAngle: 90,
      children: []
    },
    {
      id: '右', w: 100, h: 150, color: COLORS.tertiary, x: 100, y: 0,
      rotateAxis: 'Y', rotateDir: 1, transformOrigin: 'left', targetAngle: 90,
      children: []
    }
  ]
});

// Square Pyramid (Rough approximation for visual demo)
// Base 100x100. Triangles height ~100.
// Closing angle for equilateral triangles on square base is approx 63 degrees from ground, 
// so we rotate up about 117 degrees from flat? Or 90 - angle?
// Let's use simpler logic: Flat is 0. Closed is approx 70deg rotation.
const createPyramidData = () => ({
  id: '底', w: 100, h: 100, color: COLORS.primary, type: 'rect', rotateAxis: 'X', rotateDir: 0, transformOrigin: 'center',
  children: [
    {
      id: '前', w: 100, h: 100, color: COLORS.quaternary, x: 0, y: 100, type: 'triangle',
      rotateAxis: 'X', rotateDir: 1, transformOrigin: 'top', targetAngle: 70, 
      children: []
    },
    {
      id: '後', w: 100, h: 100, color: COLORS.quaternary, x: 0, y: -100, type: 'triangle',
      rotateAxis: 'X', rotateDir: -1, transformOrigin: 'bottom', targetAngle: 70,
      children: []
    },
    {
      id: '左', w: 100, h: 100, color: COLORS.quaternary, x: -100, y: 0, type: 'triangle', // Visual fix needed for side triangles rotation
      rotateAxis: 'Y', rotateDir: -1, transformOrigin: 'right', targetAngle: 70,
      // For side triangles, the SVG needs to be rotated 90deg visually to point correct way relative to hinge,
      // but simpler to just use CSS transform on the content.
      // However, for this demo, we use a wrapper to orient the triangle correctly.
      children: []
    },
    {
      id: '右', w: 100, h: 100, color: COLORS.quaternary, x: 100, y: 0, type: 'triangle',
      rotateAxis: 'Y', rotateDir: 1, transformOrigin: 'left', targetAngle: 70,
      children: []
    }
  ]
});

// --- Main Application Component ---

export default function App() {
  const [shapeType, setShapeType] = useState('cube');
  const [progress, setProgress] = useState(50); // 0 to 100
  const [rotation, setRotation] = useState({ x: -30, y: 45 });
  const [isDragging, setIsDragging] = useState(false);
  const lastMousePos = useRef({ x: 0, y: 0 });

  // Load shape data
  const shapeData = React.useMemo(() => {
    switch (shapeType) {
      case 'cuboid': return createCuboidData();
      case 'pyramid': return createPyramidData();
      case 'cube': 
      default: return createCubeData();
    }
  }, [shapeType]);

  // Handle Rotation Logic
  const handleMouseDown = (e) => {
    setIsDragging(true);
    lastMousePos.current = { x: e.clientX, y: e.clientY };
  };

  const handleTouchStart = (e) => {
    setIsDragging(true);
    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }

  const handleMouseMove = (e) => {
    if (!isDragging) return;
    const deltaX = e.clientX - lastMousePos.current.x;
    const deltaY = e.clientY - lastMousePos.current.y;
    setRotation(prev => ({
      x: prev.x + deltaY * 0.5,
      y: prev.y + deltaX * 0.5
    }));
    lastMousePos.current = { x: e.clientX, y: e.clientY };
  };

  const handleTouchMove = (e) => {
    if (!isDragging) return;
    const deltaX = e.touches[0].clientX - lastMousePos.current.x;
    const deltaY = e.touches[0].clientY - lastMousePos.current.y;
    setRotation(prev => ({
      x: prev.x + deltaY * 0.5,
      y: prev.y + deltaX * 0.5
    }));
    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }

  const handleMouseUp = () => setIsDragging(false);

  // Auto-rotate effect when not interacting (optional, keeping it static for clarity is better for teaching)
  
  // Specific fix for Pyramid side triangles orientation
  // The recursive function assumes triangles point "outward". 
  // For Left/Right triangles on a grid, we need to rotate the inner content 90deg so the base is on the hinge.
  const PyramidSideFix = ({ children, id }) => {
    if (shapeType === 'pyramid' && (id === '左' || id === '右')) {
       // Rotate the triangle visual so its base aligns with the vertical hinge
       const rotation = id === '左' ? '90deg' : '-90deg';
       return <div style={{ width: '100%', height: '100%', transform: `rotate(${rotation})` }}>{children}</div>
    }
    return children;
  }

  return (
    <div className="min-h-screen bg-slate-50 flex flex-col font-sans text-slate-800"
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      onTouchEnd={handleMouseUp}
    >
      {/* Header */}
      <header className="bg-white p-4 shadow-sm border-b border-slate-200 z-20">
        <div className="max-w-5xl mx-auto flex flex-col md:flex-row items-center justify-between gap-4">
          <div className="flex items-center gap-2">
             <Box className="w-8 h-8 text-blue-600" />
             <h1 className="text-xl md:text-2xl font-bold tracking-tight text-blue-900">
               小學數學：立體圖形展開圖
             </h1>
          </div>
          
          <div className="flex bg-slate-100 p-1 rounded-lg">
            <button 
              onClick={() => setShapeType('cube')}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-all flex items-center gap-2 ${shapeType === 'cube' ? 'bg-white shadow text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}
            >
              <Box size={16} /> 正方體
            </button>
            <button 
              onClick={() => setShapeType('cuboid')}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-all flex items-center gap-2 ${shapeType === 'cuboid' ? 'bg-white shadow text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}
            >
              <Box size={16} className="scale-x-125" /> 長方體
            </button>
            <button 
              onClick={() => setShapeType('pyramid')}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-all flex items-center gap-2 ${shapeType === 'pyramid' ? 'bg-white shadow text-blue-600' : 'text-slate-500 hover:text-slate-700'}`}
            >
              <Triangle size={16} /> 四角錐體
            </button>
          </div>
        </div>
      </header>

      {/* Main Content Area */}
      <main className="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        {/* 3D Scene Container */}
        <div 
          className="relative flex-1 bg-slate-50 cursor-move flex items-center justify-center overflow-hidden"
          style={{ 
            backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', 
            backgroundSize: '20px 20px' 
          }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
        >
          
          <div className="absolute top-4 left-4 bg-white/80 backdrop-blur p-2 rounded-lg shadow text-xs text-slate-500 pointer-events-none select-none flex items-center gap-2">
            <MousePointer2 size={14} /> 拖動畫面以旋轉視角
          </div>

          {/* The 3D Scene */}
          <div 
            className="scene"
            style={{
              perspective: '1200px',
              transformStyle: 'preserve-3d',
              width: '100%',
              height: '100%',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          >
            {/* The Root Object wrapper handles the global rotation */}
            <div
              className="object-root"
              style={{
                position: 'relative',
                transformStyle: 'preserve-3d',
                transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,
                transition: isDragging ? 'none' : 'transform 0.5s ease-out', // smooth inertia if we added it, but good for reset
              }}
            >
              {/* Root Face (Bottom) is the anchor */}
              <FoldableFace data={shapeData} progress={progress} />
            </div>
          </div>
        </div>

        {/* Controls Overlay (Bottom on mobile, Right on desktop) */}
        <div className="md:w-80 bg-white border-l border-slate-200 p-6 flex flex-col gap-6 shadow-xl z-10">
            
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <h3 className="font-bold text-slate-800 flex items-center gap-2">
                  <RefreshCcw size={18} /> 展開控制
                </h3>
                <span className="text-sm font-mono bg-blue-100 text-blue-700 px-2 py-1 rounded">
                  {progress}%
                </span>
              </div>
              
              <input
                type="range"
                min="0"
                max="100"
                value={progress}
                onChange={(e) => setProgress(Number(e.target.value))}
                className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
              />
              <div className="flex justify-between text-xs text-slate-500 font-medium">
                <span>立體圖形</span>
                <span>展開圖 (Net)</span>
              </div>
            </div>

            <div className="p-4 bg-blue-50 rounded-xl border border-blue-100 space-y-2">
               <h4 className="font-bold text-blue-800 text-sm flex items-center gap-2">
                 <Info size={16}/> 學習重點
               </h4>
               <ul className="text-sm text-blue-700 space-y-1 list-disc list-inside">
                 {shapeType === 'cube' && (
                   <>
                     <li>正方體有 6 個面。</li>
                     <li>所有面都是大小相同的正方形。</li>
                     <li>相對的面永遠不會相連。</li>
                   </>
                 )}
                 {shapeType === 'cuboid' && (
                   <>
                     <li>長方體有 6 個面。</li>
                     <li>相對的面大小和形狀相同。</li>
                     <li>相鄰的面互相垂直。</li>
                   </>
                 )}
                 {shapeType === 'pyramid' && (
                   <>
                     <li>四角錐體有一個正方形底面。</li>
                     <li>側面是 4 個三角形。</li>
                     <li>所有側面匯聚於頂點。</li>
                   </>
                 )}
               </ul>
            </div>

            <div className="mt-auto">
              <button 
                onClick={() => { setRotation({x: -30, y: 45}); setProgress(50); }}
                className="w-full py-2 border border-slate-300 rounded-lg text-slate-600 text-sm hover:bg-slate-50 transition-colors"
              >
                重置視角與狀態
              </button>
            </div>
        </div>
      </main>
    </div>
  );
}
